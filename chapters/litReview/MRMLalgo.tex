\section{Metamorphic Testing of Machine Learning Programs}\label{2.4MetamorphicTestingMachineLearning}

In the absence of a reliable oracle to predict the correct output for arbitrary inputs, machine learning programs are often very hard to test. Non-testable programs can be tested in the following ways:
\begin{itemize}
  \item Creating multiple implementations of the same program and testing them on the same inputs and if the outputs on those inputs are not the same, then an error on either of the implementations may have occurred. This approach is called pseudo-oracle.
  \item If multiple implementations do not exist, metamorphic testing can be used. In metamorphic testing, the input is modified using a metamorphic relation such that the two sets of input will generate similar outputs. If similar outputs are not observed, then there must be a defect in the program.
\end{itemize}

% Performing metamorphic testing require domain knowledge and/or familiarity with the implementation to be able to come up with the metamorphic relations to transform inputs. Murphy, Kaiser, Hu, and, Wu (2008) created a taxonomy of metamorphic relationships that can be applied to the input data for both supervised and unsupervised machine learning software. These set of properties can be used to define the metamorphic relationships so that metamorphic testing can be used as a general testing method for machine learning applications\cite{Murphy2008}. They investigated two supervised algorithms MartiRank and SVM-Light and an unsupervised system PAYL to identify basic metamorphic properties in machine learning algorithms. Similar work has also been done by Xie et al. (2009) where they identified metamorphic relations for k-nearest neighbors algorithm (k-NN) and na√Øve Bayes classifier (NBC).
Performing metamorphic testing requires domain understanding and familiarity with the program to be able to come up with the metamorphic relations to transform inputs. Murphy, Kaiser, Hu, and Wu \cite{Murphy2008} created a taxonomy of metamorphic relations that can be used for machine learning software. To use metamorphic testing as a general testing method, one can apply these properties to define metamorphic relations\cite{Murphy2008}. They investigated two supervised algorithms MartiRank and SVM-Light, and an unsupervised system PAYL to identify basic metamorphic properties in machine learning algorithms. Similar work has also been done by Xie et al. \cite{Xie2009}, where they identified metamorphic relations for $k$-nearest neighbor algorithm ($k$-NN) and Naive Bayes classifier (NB).

% MartiRank is a supervised ML algorithm that applies segmentation and sorting of the input data to create a model. The algorithm then performs similar operations from the model on the test data to produce a ranking list. 
% SVM-Light is an open-source implementation of SVM that also has a ranking mode.
% PAYL is an unsupervised machine learning application which is used to perform intrusion detection. It's dataset simply consist of TCP/IP network payloads(a stream of bytes) without any label or classification.
MartiRank is a supervised ML algorithm that applies segmentation and sorting of the input data to create a model. The algorithm then produces a ranked list of test data by performing similar operations from the model.
SVM-Light is an alternative implementation of SVM, which is open-source. It has a ranking mode too.
PAYL  is used to perform intrusion detection. It is an unsupervised machine learning application. It's dataset consist of TCP/IP network payloads(a stream of bytes) with no label or classification.

% Based on the analysis of the MartiRank algorithm, the authors realized that the actual values of the attributes were not very important but their relative values determined the model. Thus, adding a constant value to every attribute or multiplying each attribute with a positive number, should not affect the model and generate the same ranking as before. The metamorphic properties identified were: addition and multiplication.  Changing the order of examples should not affect the model or ranking since the algorithm sorts the inputs, thus, MartiRank also has permutative metamorphic property. Multiplying the data by a negative constant value will create a new sorting order which can easily be predicted. The only change to the model will be the sorting direction i.e. the algorithm will change the sorting direction but keep the sorting order intact. Therefore, MartiRank also displays an invertive metamorphic property where the new output can be predicted by taking the opposite order of the original output. MartiRank also includes inclusive and exclusive metamorphic properties. Knowing the model can help predict the position of any new elements. Similar properties are also exhibited by SVM-Light and PAYL. If the training and testing data set were transformed using an additive, multiplicative, and/or invertive relationship, then the corresponding model (hyper-plane) would be affected by being shifted, expanded, or inverted in the N dimensions. The resulting ranking of the new model applied to the new data set would be the same as the original model applied to the original dataset because each example (or point in N dimensions) would similarly be moved, and the relative distances would stay the same. SVM considers each example in the testing data independently and ranks according to the distance from the hyperplane, therefore, it has the inclusive and exclusive property. Similarly, PAYL also considers the existence (or absence) of payloads of certain lengths, and thus certainly has inclusive metamorphic properties. From more study of these applications, the authors conclude that even though this not an exhaustive list of metamorphic relations, these metamorphic properties serve as a foundation for determining the relationships and transformations that can be used for conducting metamorphic testing.
After analyzing the MartiRank algorithm, the authors realized that the relative value of the attributes is what matters, and the absolute values did not determine the model. Thus, arithmetic operations, like adding each element with a constant value or multiplying them with a positive number, did not affect the ranking. The ranking also does not change if the test data is rearranged in order. Thus, the metamorphic properties identified here were: addition, multiplication, and permutation. Multiplying the data with a negative number produces the same ranking in reverse order i.e., the algorithm will change the sorting direction but keep the order intact. Therefore, MartiRank also displays an invertive metamorphic property where the new output can be predicted by taking the opposite order of the original output. MartiRank also includes inclusive and exclusive metamorphic properties since, removing a data point or adding new data does not change the order of the original data, and the new order can be predicted very easily. If the datasets are transformed using the above properties, then the model would be shifted (for additive), expanded (for multiplicative), or inverted (for inverse). The ranking of the new dataset on the new model would still be the same because the new data points are moved similarly, and there is no change in their relative distance. Every test data point in an SVM algorithm is considered independently and ranked according to its distance from the hyperplane. Thus, it exhibits the inclusive and exclusive metamorphic properties as well. The authors conclude that even though this list of properties is not exhaustive, they still serve as a foundation for identifying transformations and relations that can be used for metamorphic testing.


Xie et al. (2009) were also building on the previous work and exploring the metamorphic relations based on the expected behavior of given machine learning problems. They present a case study on Weka, a popular machine learning framework, which is also the foundation for computational science tools such as BioWeka in bioinformatics. The authors explore k-Nearest Neighbors and Naive Bayes classifier algorithms. NBC and k-NN both calculate the mean and standard deviation of the input data. The authors identified the metamorphic relations for the two algorithms (k-NN and NBC).
Permuting the order of input data does not affect the mean or standard deviation.
Multiplying the data with -1 does not affect the standard deviation since the deviation from the mean will still be the same.
Multiplying the data with some other positive number will increase the standard deviation by the same amount. Thus, the output will still be predictable.

They created a set of random input data and used the above metamorphic relations to generate another set of inputs. Upon running the inputs on both the algorithms they realized only a subset of MRs were a necessary property of the corresponding algorithms. Using this set of MR the authors were able to uncover a defect in NBC implementation. In the case of the k-NN algorithm, none of the necessary MRs was violated
From the study of these algorithms, the authors then, define the metamorphic relations that a classification algorithm is expected to exhibit:
\begin{enumerate}
  \item Consistency with affine transformation.
  \item Permutation of class labels.
  \item Permutation of attributes.
  \item Addition of uninformative/informative attributes.
  \item Consistency with re-prediction.
  \item Addition of training samples.
  \item Addition of classes by duplicating/re-labeling samples.
  \item Removal of classes/samples.
\end{enumerate}
Next, the authors introduce the notion of validation and verification. Validation refers to choosing the most appropriate algorithm to solve a problem. Verification refers to whether the implemented algorithm is correct or not. Current, software testing methods have not addressed the problem of validation and only focus on verification.

Chen et al. \cite{Chen2016} presented a tool called METRIC. It is a specification-based tool for identifying metamorphic relations. In this framework, the input domain is partitioned using program specifications. The partitioning is done in terms of categories, choices, and complete test frames. He then conducted an empirical study with 19 participants suggest that METRIC is capable and effective at identifying metamorphic relations. Using affine transformations as metamorphic relation to test machine learning algorithms

Sometimes a single metamorphic property is not enough to uncover defects and we have to use multiple properties. These multiple properties can be applied in any combination. Segura did an research on how to combining these properties
\cite{Segura2016} The metamorphic relations can be combined such that the output from one metamorphic transformation is used as input for the next. This process is called Iterative Metamorphic Testing (IMT). IMT can be used to iteratively apply a sequence of metamorphic relations by reusing the follow-up test cases as a source for the next MR.
 \par
% New metamorphic relations can be constructed by combining several existing relations. This is called Composition of Metamorphic Relations (CMR)\cite{Segura2016}. The rationale behind this method is that the resulting relations should embed all properties of the original metamorphic relations, and thus they should provide similar effectiveness with a fewer number of metamorphic relations and test executions. Two metamorphic relations are considered "compositable" if the follow-up test cases of one of the relations can always be used as a source test case of the other. The composition is sensitive to the order of metamorphic relations and generalizable to any number of them. Determining whether two metamorphic relations are composable is a manual task. 
New metamorphic relations can be created by combining multiple existing relations. This is called the Composition of Metamorphic Relations (CMR)\cite{Segura2016}. If the follow-up test data of one metamorphic relation can be used as an input source for the other, then the two metamorphic relations are considered "compositable". It is expected that the final relation will encapsulate the properties of the original metamorphic relations and provide the same effectiveness with fewer test executions. The composition can be generalized to two or more metamorphic relations and is also sensitive to the order in which they are applied. Deciding whether the metamorphic relations are composable is a manual task. 

