\section{Metamorphic Testing Machine Learning Programs}

In the absence of a reliable oracle to indicate the correct output for arbitrary inputs, machine learning programs are often very hard to test. Non-testable programs can be tested in the following ways:
\begin{itemize}
  \item Creating multiple implementations of the same program and testing them on the same inputs and comparing the results. If the outputs are not the same then either of the implementations may contain an error. This approach is called pseudo-oracle.
  \item In the absence of multiple oracles, metamorphic testing can be used. In metamorphic testing, the input is modified using a metamorphic relation such that the two sets of input will generate similar outputs. If similar outputs are not observed then there must be a defect.
\end{itemize}

Performing metamorphic testing require domain knowledge and/or familiarity with the implementation to be able to come up with the metamorphic relations to transform inputs. Murphy, Kaiser, Hu, and, Wu (2008) created a taxonomy of metamorphic relationships that can be applied to the input data for both supervised and unsupervised machine learning software. These set of properties can be used to define the metamorphic relationships so that metamorphic testing can be used as a general testing method for machine learning applications\cite{Murphy2008}. They investigated two supervised algorithms MartiRank and SVM-Light and an unsupervised system PAYL to identify basic metamorphic properties in machine learning algorithms. Similar work has also been done by Xie et al. (2009) where they identified metamorphic relations for k-nearest neighbors algorithm (k-NN) and na√Øve Bayes classifier (NBC).
MartiRank is a supervised ML algorithm that applies segmentation and sorting of the input data to create a model. The algorithm then performs similar operations from the model on the test data to produce a ranking list. 
SVM-Light is an open-source implementation of SVM that also has a ranking mode.
PAYL is an unsupervised machine learning application which is used to perform intrusion detection. It's dataset simply consist of TCP/IP network payloads(a stream of bytes) without any label or classification.

Based on the analysis of the MartiRank algorithm, the authors realized that the actual values of the attributes were not very important but their relative values determined the model. Thus, adding a constant value to every attribute or multiplying each attribute with a positive number, should not affect the model and generate the same ranking as before. The metamorphic properties identified were: addition and multiplication.  Changing the order of examples should not affect the model or ranking since the algorithm sorts the inputs, thus, MartiRank also has permutative metamorphic property. Multiplying the data by a negative constant value will create a new sorting order which can easily be predicted. The only change to the model will be the sorting direction i.e. the algorithm will change the sorting direction but keep the sorting order intact. Therefore, MartiRank also displays an invertive metamorphic property where the new output can be predicted by taking the opposite order of the original output. MartiRank also includes inclusive and exclusive metamorphic properties. Knowing the model can help predict the position of any new elements. Similar properties are also exhibited by SVM-Light and PAYL. If the training and testing data set were transformed using an additive, multiplicative, and/or invertive relationship, then the corresponding model (hyper-plane) would be affected by being shifted, expanded, or inverted in the N dimensions. The resulting ranking of the new model applied to the new data set would be the same as the original model applied to the original dataset because each example (or point in N dimensions) would similarly be moved, and the relative distances would stay the same. SVM considers each example in the testing data independently and ranks according to the distance from the hyperplane, therefore, it has the inclusive and exclusive property. Similarly, PAYL also considers the existence (or absence) of payloads of certain lengths, and thus certainly has inclusive metamorphic properties. From more study of these applications, the authors conclude that even though this not an exhaustive list of metamorphic relations, these metamorphic properties serve as a foundation for determining the relationships and transformations that can be used for conducting metamorphic testing.


Xie et al. (2009) were also building on the previous work and exploring the metamorphic relations based on the expected behavior of given machine learning problems. They present a case study on Weka, a popular machine learning framework, which is also the foundation for computational science tools such as BioWeka in bioinformatics. The authors explore k-Nearest Neighbors and Naive Bayes classifier algorithms. NBC and k-NN both calculate the mean and standard deviation of the input data. The authors identified the metamorphic relations for the two algorithms (k-NN and NBC).
Permuting the order of input data does not affect the mean or standard deviation.
Multiplying the data with -1 does not affect the standard deviation since the deviation from the mean will still be the same.
Multiplying the data with some other positive number will increase the standard deviation by the same amount. Thus, the output will still be predictable.

They created a set of random input data and used the above metamorphic relationships to generate another set of inputs. Upon running the inputs on both the algorithms they realized only a subset of MRs were a necessary property of the corresponding algorithms. Using this set of MR the authors were able to uncover a defect in NBC implementation. In the case of the k-NN algorithm, none of the necessary MRs was violated
From the study of these algorithms, the authors then, define the metamorphic relations that a classification algorithm is expected to exhibit:
\begin{enumerate}
  \item Consistency with affine transformation.
  \item Permutation of class labels.
  \item Permutation of attributes.
  \item Addition of uninformative/informative attributes.
  \item Consistency with re-prediction.
  \item Addition of training samples.
  \item Addition of classes by duplicating/re-labeling samples.
  \item Removal of classes/samples.
\end{enumerate}
Next, the authors introduce the notion of validation and verification. Validation refers to choosing the most appropriate algorithm to solve a problem. Verification refers to whether the implemented algorithm is correct or not. Current, software testing methods have not addressed the problem of validation and only focus on verification.

Chen et al. \cite{Chen2016} also presented a specification-based tool called METRIC for the identification of metamorphic relations. In this framework, the program specification is used to partition the input domain in terms of categories, choices and complete test frames. The results of an empirical study with 19 participants suggest that METRIC is effective and efficient at identifying metamorphic relations.

Sometimes a single metamorphic property is not enough to uncover defects and we have to use multiple properties. These multiple properties can be applied in any combination. Segura did an research on how to combining these properties
\cite{Segura2016} Iterative Metamorphic Testing (IMT) can be used to systematically exploit more information from metamorphic tests, by applying metamorphic relations iteratively. In IMT, a sequence of metamorphic relations is applied in a chain style, by reusing the follow-up test case of each metamorphic relation as the source test case of the next metamorphic relation. \par
New metamorphic relations can be constructed by combining several existing relations. This is called Composition of Metamorphic Relations (CMR)\cite{Segura2016}. The rationale behind this method is that the resulting relations should embed all properties of the original metamorphic relations, and thus they should provide similar effectiveness with a fewer number of metamorphic relations and test executions. Two metamorphic relations are considered "compositable" if the follow-up test cases of one of the relations can always be used as a source test case of the other. The composition is sensitive to the order of metamorphic relations and generalizable to any number of them. Determining whether two metamorphic relations are composable is a manual task. 

