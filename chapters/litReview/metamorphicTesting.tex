\section{Metamorphic Testing}

In the absence of a reliable oracle to indicate the correct output for arbitrary inputs, machine learning programs are often very hard to test. It is almost impossible to generate all the possible combinations of test cases to completely test a program which is why a lot of research is being conducted to develop more error-revealing test case selection strategies. A test case is called error-revealing if it is able to detect an error in the software otherwise it is labeled successful. Successful test case are the cases for which the program successfully computes the correct output. Since these test cases do not reveal any error, they are considered less important and are often not investigated further or, set aside for regression testing. {Zhou et al. (Metamorphic Testing and Its Applications ∗ † Zhi Quan Zhou‡∥, D.H. Huang‡, T.H. Tse§, Zongyuan Yang ¶, Haitao Huang ¶, and T. Y. Chen ‡)(Metamorphic testing and beyond) }

Chen, Cheung, and Yiu (1998) first introduced the idea of metamorphic testing to make use of valuable information in successful test cases in order to answer the oracle problem. Metamorphic testing reuses successful test cases to generate followup test cases according to metamorphic relations whose output can easily be predicted. A metamorphic relation(MR) is an expected relation among input and outputs of multiple executions of the target program(Metamorphic testing and beyond)(METRIC: METamorphic Relation Identification based on the Category - choice framework). To formally define MRs we can assume a function $f$ which produces the output $f(x)$ on input $x$. The MRs of the function can then be used to generate a transformation function $t$, which, when applied to input $x$ produces $t(x)$. This transformed input can then be run through the function $f$ and the transformation allows us to predict the value of $f(t(x))$(Automatic system testing of programs without test oracle). 
A simple example of a MR would be a program that calculates mean of a set of numbers. Certain transformations of the set of numbers will result in the same value for mean like: permuting the order of numbers, since, this neither changes the number of elements in the set nor the value of any element. Another transformation that can be used would be multiplying each number in the set with -1. The new mean will be the negative value of the previous mean.

System under test(SUT)

\subsection{Properties of a good metamorphic relation}
Segura et al. did an extensive review of metamorphic testing with 119 papers published between 1998 and 2015 to answer important research questions about origin, current state, and, future of metamorphic testing. They identified that the most popular use of metamorphic testing was in web services, followed by computer graphics, simulation and modelling, and, embedded systems. They also found some other domains of application like financial software, optimization programs, and encryption programs.
 
They first studied the properties of effective metamorphic relations. To select the most effective metamorphic relations to detect faults one must have.
\begin{itemize}
	\item A good understanding of the problem domain since good metamorphic relations are usually strongly inspired by the semantics of the program under test.
	\item Metamorphic relations that make execution of the follow-up test case as different as possible from the source test case.
	\item Metamorphic relations derived from specific parts of the system since they are more effective than those targeting the whole system.
	\item Formally described metamorphic relations. In particular, a metamorphic relation should be a 3-tuple composed of $i)$ relation between the inputs of the source and follow-up test cases, $ii)$ relation between the outputs of source and follow-up test cases, and $iii)$ program function.
\end{itemize}
			





It should be noted that MT does not check the correctness of individual outputs. Instead, it checks the relations among several executions. Since no manual output predictions and comparisons are required, MT can be efficient and fully automated. \cite{Segura2016} The execution of a metamorphic test case is typically performed in two steps. First, a follow-up test case is generated by applying a transformation to the inputs of a source test case. Second, source and follow-up test cases are executed, checking whether their outputs violate the metamorphic relation. \par
	\subsection{Automatic System Testing of Programs without Test Oracles \cite{Murphy2009}}
	A number of frameworks have been developed to automate the process of metamorphic testing. Gotlieb and Botella \cite{Gotlieb2003} presented a framework called Automated Metamorphic Testing (AMT) to automatically generate test data for metamorphic relations. Given the source code of a program written in C and a metamorphic relation, AMT tries to find test cases that violate the relation. The underlying method is based on the translation of the code into an equivalent constraint logic program over finite domains. Other techniques like “special values” and random testing can also be used as source test cases for metamorphic testing. Genetic algorithms have also been used for the selection of source test cases, to maximize the paths traversed in the program under test.
	
		In this paper the authors have demonstrated the usefulness of metamorphic testing in assessing the quality of applications without test oracles. Comparing the outputs of the morphed data still remains a challenge especially if the data set is large or not in human readable format. The authors presented an approach called ``Automated Metamorphic System Testing'' to automate the metamorphic testing by considering the system as a blackbox and checking if the metamorphic properties holds after execution of the system. They also present another approach “Heuristic Metamorphic Testing” to reduce false positives and address some non-determinism. Unlike in the previous papers, here, the authors are focusing to improve the metamorphic testing technique itself. They list some benefits of using metamorphic testing: it can be used on broader domain of applications that display metamorphic properties, and it treats the application under test as a black box and does not require detailed understanding of the source code. \cite{Murphy2009}
		
        
		\cite{Segura2016} Iterative Metamorphic Testing (IMT) can be used to systematically exploit more information from metamorphic tests, by applying metamorphic relations iteratively. In IMT, a sequence of metamorphic relations is applied in a chain style, by reusing the follow-up test case of each metamorphic relation as the source test case of the next metamorphic relation. \par
		Murphy et al. \cite{Murphy2009} presented a framework named Amsterdam for the automated application of metamorphic testing. The tool takes as inputs the program under test and a set of metamorphic relations, defined in an XML file. Then, Amsterdam automatically runs the program, applies the metamorphic relations and checks the results.
		
		Automated Metamorphic System Testing: This technique can be used to test the application in development environment as well as in production as long as the users are only provided the output from the original execution and not the result from transformed input. In this model $i)$ Metamorphic properties are specified by the tester and applied to the input. $ii)$ The original input is fed into the application which is treated as a black-box and a transformation of the input is also generated. $iii)$ That transformed input is fed into a separate instance of the application running in a separate sandbox. $iv)$ When the invocations are finished, the results are compared and if they do not match according to the specifications, there is an error.
		Tester need not write any code and only needs to specify the metamorphic properties. They don't need to know the source code or other implementation details.
		Amsterdam framework: The metamorphic properties are specified using XML file. The specification consists of three parts: $i)$ how to transform the input, $ii)$ how to execute the program, and, $iii)$ how to compare the outputs.\par
		Heuristic Metamorphic testing: This method allows for small differences in outputs, in a meaningful way according to the application being used to address the problems of false positives and non-determinism. Imprecision in floating point calculation and representation of irrational number such as may result in failure of metamorphic testing even if the implementation is correct. If two outputs are close enough they are considered the same. The definition of close enough depends on the application and in complex applications checking semantic similarity may also be required.\cite{Murphy2009}
		
		
Although metamorphic testing presents a lot of opportunities to expand on the existing testing processes, they also have some limitations. They then list some of the limitations of using metamorphic testing: \cite{Murphy2009}
		\begin{itemize}
			\item	Manual transformation of large input data can be laborious and error-prone. They need special tools to transform the input.
			\item Comparing the outputs(some of which may be very large and/or in not human-readable format) of the input data can be tedious.
			\item Floating point calculations can also lead to imprecision even though the calculations are programmatically correct.
			\item Coming up with the initial test-cases is also a challenge as some defects may only occur under certain inputs.
		\end{itemize}
		
		Some of the research challenges identified by the authors are:{A Survey on Metamorphic Testing \cite{Segura2016}}
		\begin{itemize}
			\item Lack of guidelines, with step-by-step process to guide testers, experts, and beginners, in the construction of good metamorphic relations.
			\item Prioritisation and minimisation of metamorphic relations: It is worth mentioning that test case minimisation is a NP-hard problem and therefore heuristic techniques should be explored.
			\item Generation of likely metamorphic relations.
			\item Combination of metamorphic relations.
			\item Automated generation of best possible source test cases.
			\item Lack of metamorphic testing tools.
		\end{itemize}
