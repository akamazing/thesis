\section{Software testing}
Testing is one of the most important activity in software development life cycle. Bertolino (2007) define software testing as, "observing the execution of a software system to validate whether it behaves as intended and identify potential malfunctions". Testing is widely used in industry for quality assurance purposes. Software testing is an umbrella term that encompasses a wide range of different sub tasks, like unit testing a small piece of code, acceptance testing a large information system for customer validation, monitoring the application at run-time to ensure uninterrupted service, etc.\cite{Bertolino2007} A study by Beizer (2006) has estimated that software testing can use up to fifty percent, or more, of the total development cost. Thus, it is clear that program software testing is worthy of our attention for research and improvement.\cite{Beizer1990} 
Weyuker (1982) categorizes the testing research activities into three categories:
\begin{enumerate}
  \item Develop a sound theoretical basis for testing.
  \item Devise and improve testing methodologies, especially the mechanizable ones.
  \item Define accurate measurement criteria for testing data adequately.
\end{enumerate}

However,  there are a lot of uncertainties in program testing and it is often not so straightforward to test programs. These Uncertainties in most systems are introduced by either human decisions, machine learning algorithms, external libraries, or sensing variability mostly due to the need to support deep interactions between interconnected software systems and their users and execution environments. In the context of software testing, the two fundamental problems are: increased ambiguity of what constitutes the input space and what is deemed as acceptable behavior in absence of an oracle. \cite{Chen2002} \cite(Elbaum2014)
Although non-testable programs occur in all areas of data processing, the problem is undoubtedly most acute in the area of numerical computations, particularly where floating point arithmetic is used. While performing mathematical computations, errors from three sources can creep in:
\begin{enumerate}
  \item The mathematical model used to do the computations.
  \item Programs written to implement the computation.
  \item The features of the environment like round-off, floating point operations etc.
\end{enumerate}\cite{Weyuker}


 One of the first problems that testers run into is that they don't have access to acceptable output to test the program output against. This problem is often referred to as the Oracle problem. Weyuker provides founding definition of an oracle as a system that determines the correctness of the solution by comparing the systemâ€™s output to the one that it predicts. As per Weyuker, non-testable programs can be defined as the programs for which such oracles do not exist. The term non-testable is used, from the point of view of correctness testing. If one cannot decide whether or not the output is correct or have to spend some extraordinary amount of resources to do so, testing those systems may not be worth it.\cite{Weyuker}
 
 A complementary way to deal with uncertainty at the other end of the testing process is to develop more sophisticated oracles. If the oracles are relaxed too much to tolerate the variations introduced by uncertainties, there is an inherent risk for the uncertain behavior to mask a fault. On the other hand, if the oracles are too narrow it may cause them to generate false positives, resulting in wasted developer's time.\cite(Elbaum2014)
 
 Many techniques have since been developed to test these set of non-testable programs. One way of elevating the oracle-problem is through the use of pseudo oracle. It is also referred to as dual-coding and is used in highly critical software.\cite{Weyuker}\cite{Murphy2009}. Pseudo-oracles are multiple implementation of same specification of the original program under test.
 However, dual coding comes with it's own set of problems. As the authors [this and this ] pointed out that pseudo-oracle requires at least two implementation and it may come out to be a lot of overhead or, multiple implementation may not exist or, the multiple implementation may be created by the same or same set of developers prone to make same mistakes.
 In light of shortcomings of the testing process the authors finally make five recommendation for items to be considered as a part of documentation during testing.
\begin{enumerate}
  \item The criteria used to select the test data.
  \item The degree to which the criteria were fulfilled.
  \item The test data, the program ran on.
  \item The output of each of each test datum.
  \item How the results were determined to be correct or acceptable.
\end{enumerate}
Although these recommendations do not solve the problem of non-testable programs, however, they do provide information on whether the program should be considered adequately tested or not.\cite(Weyuker)


But, due to a great deal of overhead involved pseudo-oracles may not be practical for every situation.  
A different, and frequently employed course of action is to run the program on 'simplified' data for which the correctness of the results can be accurately and readily determined. The tester then extrapolates from the correctness of the test results on these simple cases to correctness for more complicated cases. In this case, we are deliberately omitting test cases even though these cases may have been identified as important. They are not being omitted because it is not expected that they will yield substantial additional information, but rather because they are impossible, too difficult, or too expensive to check. The problem with using simple test cases is very obvious i.e. it is common for central cases to work perfectly whereas boundary cases to cause errors. \cite{Weyuker}

Even in the absence of oracles the users often have a ballpark idea of what the correct answer would look like without knowing the correct answer. In such cases, we make use of partial oracles. It is relatively easier to test the systems on simpler inputs for which the output is known. There is rarely a single correct answer in these types of computations. Rather, the goal is generally an approximation which is within a designated tolerance of the exact solution. 